.comment;asmblr.rno

.chapter;The Assembler
.header level 1;The ASxxxx Assemblers

The ASxxxx assemblers are a series of microprocessor assemblers
written in the C programming language. Each
assembler has a device specific section which includes:

.list 1
.list element
device description, byte order, and file extension information
.list element
a table of the assembler general directives, special device directives,
assembler mnemonics and associated operation codes
.list element
machine specific code for processing the device mnemonics,
addressing modes, and special directives
.end list

.break
The device specific information is detailed in the appendices.

The assemblers have a common device independent section which
handles the details of file input_/output, symbol table generation,
program_/data areas, expression analysis, and assembler directive
processing.
.skip
The assemblers provide the following features:

.list 1
.list element;Command string control of assembly functions
.list element;Alphabetized, formatted symbol table listing
.list element;Relocatable object modules
.list element;Global symbols for linking object modules
.list element;Conditional assembly directives
.list element;Program sectioning directives
.end list

ASxxxx assembles one or more source files
into a single relocatable ascii object file. The output
of the ASxxxx assemblers consists of an ascii relocatable object
file(*.rel), an assembly listing file(*.lst), and a symbol file(*.sym).


.header level 2;Assembly Pass 1

During pass 1, ASxxxx opens all source files and performs a rudimenatry
assembly of each source statement. During this process all symbol tables
are built, program sections defined, and number of bytes for each
assembled source line is estimated.

At the end of pass 1 all undefined symbols may be made global (external)
using the ASxxxx switch -g, otherwise undefined symbols will be flagged
as errors during succeeding passes.


.header level 2;Assembly Pass 2

During pass 2 the ASxxxx assembler resolves forward references and determines
the number of bytes for each assembled line. The number of bytes used
by a particular assembler instruction may depend upon the addressing mode,
whether the instruction allows multiple forms based upon the relative
distance to the addressed location, or other factors. Pass 2 resolves these
cases and determines the address of all symbols.


.header level 2;Assembly Pass 3

Pass 3 by the assembler generates the listing file, the relocatable
output file, and the symbol tables. Also during pass 3 the errors will
be reported.

The relocatable object file is an ascii file containing symbol references
and definitions, program area definitions, and the relocatable assembled
code, the linker ASLINK will use this information to generate an absolute
load file (Motorola or Intel formats).


.header level 1;SOURCE PROGRAM FORMAT


.header level 2;Statement Format

A source program is composed of assembly-language statements. Each statement
must be completed on one line. A line may contain a maximum of 128 characters,
longer lines are truncated and lost.

An ASxxxx assembler statement may have as many as four fields. These
fields are identified by their order within the statement and/or by
separating characters between fields. The general format of the
ASxxxx statement is:

.skip;.break;.indent 6
[label:]	Operator	Operand		[;Comment(s)]

The label and comment fields are optional. The operator and operand
fields are interdependent. The operator field may be an assembler
directive or an assembly mnemonic. The operand field may be optional
or required as defined in the context of the operator.

ASxxxx interprets and processes source statements one at a time.
Each statement causes a particular operation to be performed.


.header level 3;Label Field

A label is a user-defined symbol which is assigned the value of the
current location counter and entered into the user defined symbol
table.  The current location counter is used by ASxxxx to assign memory
addresses to the source program statements as they are encountered during the
assembly process.  Thus a label is a means of symbolically referring
to a specific statement.

When a program section is absolute, the value of the current location
counter is absolute; its value references an absolute memory address.
Similarly, when a program section is relocatable, the value of the
current location counter is relocatable. A relocation bias calculated
at link time is added to the apparent value of the current location counter
to establish its effective absolute address at execution time.
(The user can also force the linker to relocate sections defined
as absolute. This may be required under special circumstances.)

If present, a label must be the first field in a source statement and
must be terminated by a colon (:).  For example, if the value of the
current location counter is absolute 01F0(H), the statement:
.skip;.indent 6
abcd:	nop
.skip;.break
assigns the value 01F0(H) to the label abcd.  If the location counter
value were relocatable, the final value of abcd would be 01F0(H)+K,
where K represents the relocation bias of the program section, as
calculated by the linker at link time.

More than one label may appear within a single label field.
Each label so specified is assigned the same address value.  For
example, if the value of the current location counter is 1FF0(H),
the multiple labels in the following statement are each assigned
the value 1FF0(H):

.skip;.indent 6
abcd:	a_q:	$abc:	nop

Multiple labels may also appear on successive lines.  For
example, the statements

.skip
.indent 6;abcd:
.indent 6;a_q:
.indent 6;$abc:	nop
.skip
likewise cause the same value to be assigned to all three labels.

A double colon (::) defines the label as a global symbol.  For
example,  the statement
.skip;.indent 6
abcd::	nop
.skip
establishes the label abcd as a global symbol.  The distinguishing
attribute of a global symbol is that it can be referenced from within an
object module other than the module in which the symbol is defined.
References to this label in other modules are resolved when the
modules are linked as a composite executable image.

.skip;.break
The legal characters for defining labels are:

.skip;
.break;.indent 8;A through Z
.break;.indent 8;a through z
.break;.indent 8;0 through 9
.break;.indent 8;_. (Period)
.break;.indent 8;_$ (Dollar sign)
.break;.indent 8;__ (underscore)


A label may be any length, however, only the first eight (8) characters
are significant and, therefore must be unique among all labels in the
source program (not necessarily among separately compiled modules).
An error code(s)
(m#or#p) will be generated in the assembly listing if the first eight
characters in two or more labels are the same.  The m code is caused
by the redeclaration of the symbol or its reference by another statement.
The p code is generated because the symbols location is changing on each
pass through the source file.

The label must not start with the characters 0-9, as this designates a
local symbol with special attributes described in a later section.

The label must not start with the sequence $$, as this represents the
temporary radix 16 for constants.


.header level 3;Operator Field

The operator field specifies the action to be performed.  It may
consist of an instruction mnemonic (op code) or an assembler directive.

When the operator is an instruction mnemonic, a machine instruction is
generated and the assembler evaluates the addresses of the operands
which follow.  When the operator is a directive ASxxxx performs certain
control actions or processing operations during assembly of the source
program.

Leading and trailing spaces or tabs in the operator field have no
significance;  such characters serve only to separate the operator
field from the preceeding and following fields.

An operator is terminated by a space, tab or end of line.


.header level 3;Operand Field

When the operator is an instruction mnemonic (op code), the operand
field contains program variables that are to be evaluated/manipulated
by the operator.

Operands may be expressions or symbols, depending on the operator.
Multiple expressions used in the operand fields may be separated
by a comma.  An operand should be preceeded by an operator field;
if it is not, the statement will give an error (q or o). All operands
following instruction mnemonics are treated as expressions.

The operand field is terminated by a semicolon when the field is followed
by a comment.  For example, in the following statement:
.skip;.indent 6
label:	lda	abcd,x		;Comment field
.skip
the tab between lda and abcd terminates the operator field and
defines the beginning of the operand field;  a comma separates the
operands abcd and x; and a semicolon terminates the operand field
and defines the beginning of the comment field.  When no comment field
follows, the operand field is terminated by the end of the source line.


.header level 3;Comment Field

The comment field begins with a semicolon and extends through the
end of the line.  This field is optional and may contain any 7-bit
ascii character except null.

Comments do not affect assembly processing or program execution.


.header level 1;SYMBOLS AND EXPRESSIONS

This section describes the generic components of the ASxxxx assemblers:
the character set,  the conventions observed in constructing symbols,
and the use of numbers, operators, and expressions.


.header level 2;Character Set

The following characters are legal in ASxxxx source programs:

.list 1
.list element
The letters A through Z.  Both upper- and lower-case letters
are acceptable.  The assemblers are case sensitive, i.e.
ABCD and abcd are different symbols. (The assemblers can be made
case insensitive by recompiling with the appropriate switches.)
.list element
The digits 0 through 9
.list element
The characters  _. (period),  _$ (dollar sign), and  __ (underscore).
.list element
The special characters listed in Tables 1 through 6.
.end list

Tables 1 through 6 describe the various ASxxxx label and field
terminators, assignment operators, operand separators, assembly,
unary, binary, and radix operators.

.page
.test page 15
Table#1#########Label Terminators and Assignment Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
:###Colon###############
Label terminator.
.skip;.indent -24
::##Double#colon########
Label Terminator; defines the label as a global label.
.skip;.indent -24
_=###Equal#sign##########
Direct assignment operator.
.skip;.indent -24
_=_=##Double#equal########
Direct assignment operator;
.indent -24
####sign################
defines the symbol as a global symbol.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 12
Table#2#########Field Terminators and Operand Separators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
####Tab#################
Item or field terminator.
.skip;.indent -24
####Space###############
Item or field terminator.
.skip;.indent -24
,###Comma###############
Operand field separator.
.skip;.indent -24
;###Semicolon###########
Comment field indicator.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 15
Table#3#########Assembler Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
_####Number#sign#########
Immediate expression indicator.
.skip;.indent -24
_.###Period##############
Current location counter.
.skip;.indent -24
(###Left#parenthesis####
Expression delimiter.
.skip;.indent -24
)###Right#parenthesis###
Expression delimeter.
.left margin -32
.skip
----------------------------------------------------------------
.skip 5

.test page 26
Table#4#########Unary Operators
.break
----------------------------------------------------------------
.left margin +40
.skip;.indent -32
_<###Left#bracket########_<FEDC###
Produces the lower byte value of the expression. (DC)
.skip;.indent -32
_>###Right#bracket#######_>FEDC###
Produces the upper byte value of the expression. (FE)
.skip;.indent -32
_+###Plus#sign###########_+A######
Positive value of A
.skip;.indent -32
_-###Minus#sign##########_-A######
Produces the negative (2's complement) of A.
.skip;.indent -32
_~###Tilde###############_~A######
Produces the 1's complement of A.
.skip;.indent -32
_'###Single#quote########_'D######
Produces the value of the character D.
.skip;.indent -32
_"###Double#quote########_"AB#####
Produces the double byte value for AB.
.skip;.indent -32
_\###Backslash###########_'_\n#####
Unix style characters
.break
_\b, _\f, _\n, _\r, _\t
.indent -32
#####################or#_'_\001###
or octal byte values.
.left margin -40
.skip
----------------------------------------------------------------
.skip 5

.test page 40
Table#5#########Binary Operators
.break
----------------------------------------------------------------
.left margin +40
.skip;.indent -32
_<_<##Double##########0800#_<_<#4###
Produces the 4 bit
.indent -32
####Left#bracket################
left-shifted value of 0800. (8000)
.skip;.indent -32
_>_>##Double##########0800#_>_>#4###
Produces the 4 bit
.indent -32
####Right#bracket###############
right-shifted value of 0800. (0080)
.skip;.indent -32
_+###Plus#sign#######A#_+#B#######
Arithmetic Addition operator.
.skip;.indent -32
_-###Minus#sign######A#_-#B#######
Arithmetic Subtraction operator.
.skip;.indent -32
*###Asterisk########A#*#B#######
Arithmetic Multiplication operator. (signed 16-bit)
.skip;.indent -32
/###Slash###########A#/#B#######
Arithmetic Division operator. (signed 16-bit quotient)
.skip;.indent -32
_&###Ampersand#######A#_&#B#######
Logical AND operator.
.skip;.indent -32
_|###Bar#############A#_|#B#######
Logical OR operator.
.skip;.indent -32
_%###Percent#sign####A#_%#B#######
Modulus operator.
.break
(16-bit value)
.skip;.indent -32
_^###Up#arrow#or#####A#_^#B#######
EXCLUSIVE OR operator.
.indent -32
####circumflex
.left margin -40
.skip
----------------------------------------------------------------
.skip 5

.test page 12
Table#6#########Temporary Radix Operators
.break
----------------------------------------------------------------
.left margin +32
.skip;.indent -24
$%,###0b,#0B############
Binary radix operator.
.skip;.indent -24
$_&,###0o,#0O,#0q,#0Q####
Octal radix operator.
.skip;.indent -24
$_#,###0d,#0D############
Decimal radix operator.
.skip;.indent -24
$$,###0h,#0H,#0x,#0X####
Hexidecimal radix operator.
.left margin -24
.skip 2
Potential ambiguities arising from the use of 0b and 0d as
temporary radix operators may be circumvented by preceding
all non-prefixed hexidecimal numbers with 00.  Leading 0's are
required in any case where the first hexidecimal digit is abcdef
as the assembler will treat the letter sequence as a label.
.left margin -8
.skip
----------------------------------------------------------------
.skip 5


.header level 2;User-Defined Symbols

User-defined symbols are those symbols that are equated to a specific value
through a direct assignment statement or appear as labels.  These symbols
are added to the User Symbol Table as they are encountered during
assembly.
.skip
The following rules govern the creation of user-defined symbols:
.list 1
.list element
Symbols can be composed of alphanumeric characters,
dollar signs (_$), periods (_.), and underscores (__) only.
.list element
The first character of a symbol must not be a number
(except in the case of local symbols).
.list element
The first eight characters of a symbol must be unique.
A symbol can be written with more than eight legal characters,
but the ninth and subsequent characters are ignored.
.list element
Spaces and Tabs must not be embedded within a symbol.
.end list


.header level 2;Local Symbols

Local symbols are specially formatted symbols used as labels within a
block of coding that has been delimited as a local symbol block.
Local symbols are of the form n$, where n is a decimal integer from
0 to 255, inclusive.  Examples of local symbols are:
.skip
.indent 6;1$
.indent 6;27$
.indent 6;138$
.indent 6;244$

The range of a local symbol block consists of those statements
between two normally constructed symbolic labels. Note that a
statement of the form:
.skip
.indent 6;ALPHA = EXPRESSION
.skip
is a direct assignment statement but does not create a label and thus
does not delimit the range of a local symbol block.

Note that the range of a local symbol block may extend across
program areas.

Local symbols provide a convenient means of generating labels for branch
instructions and other such references within local symbol blocks.
Using local symbols reduces the possibility of symbols with multiple
definitions appearing within a user program. In addition, the use of local
symbols differentiates entry-point labels from local labels, since
local labels cannot be referenced from outside their respective
local symbol blocks.  Thus, local symbols of the same name can appear
in other local symbol blocks without conflict. Local symbols require
less symbol table space than normal symbols. Their use is recommended.

The use of the same local symbol within a local symbol block will
generate one or both of the m or p errors.
.test page 15
.skip
Example of local symbols:
.skip;.literal
	a:	ldx	#atable	;get table address
		lda	#0d48	;table length
	1$:	clr	,x+	;clear
		deca
		bne	1$
		
	b:	ldx	#btable	;get table address
		lda	#0d48	;table length
	1$:	clr	,x+	;clear
		deca
		bne	1$
.end literal		


.header level 2;Current Location Counter

The period (_.) is the symbol for the current location counter.
When used in the operand field of an instruction, the period
represents the address of the first byte of the instruction:

.skip;.literal
	AS:	ldx	#.	;The period (.) refers to
				;the address of the ldx
				;instruction.
.end literal

When used in the operand field
of an ASxxxx directive, it represents the address of the current
byte or word:

.skip;.literal
	QK = 0

	.word	0xFFFE,.+4,QK	;The operand .+4 in the .word
				;directive represents a value
				;stored in the second of the
				;three words during assembly.
.end literal

If we assume the current value of the program counter is 0H0200, then
during assembly, ASxxxx reserves three words of storage starting at
location 0H0200.  The first value, a hexidecimal constant FFFE, will
be stored at location 0H0200. The second value represented by .+4
will be stored at location 0H0202, its value will be 0H0206 ( = 0H0202 + 4).
The third value defined by the symbol QK will be placed at location
0H0204.

At the beginning of each assembly pass, ASxxxx resets the location
counter.  Normally, consecutive memory locations are assigned
to each byte of object code generated.  However, the value of the
location counter can be changed through a direct assignment statement
of the following form:

.skip
.indent 6;_. = _. _+ expression
.skip

The new location counter can only be specified relative to the current
location counter.  Neglecting to specify the current program counter
along with the expression on the right side of the assignment operator
will generate the (.) error.  (Absolute program areas may use
the .org directive to specify the absolute location of the current
program counter.)
.skip
The following coding illustrates the use of the current location counter:

.skip;.literal
	.area	CODE1	(ABS)	;program area CODE1
				;is ABSOLUTE

	.org	0H100		;set location to
				;0H100 absolute

num1:	ldx	#.+0H10		;The label num1 has
				;the value 0H100.
				;X is loaded with
				;0H100 + 0H10

	.org	0H130		;location counter
				;set to 0H130

num2:	ldy	#.		;The label num2 has
				;the value 0H130.
				;Y is loaded with
				;value 0H130.


	.area	CODE2	(REL)	;program area CODE2
				;is RELOCATABLE

	. = . + 0H20		;Set location counter
				;to relocatable 0H20 of
				;the program section.

num3:	.word	0		;The label num3 has
				;the value
				;of relocatable 0H20.

	. = . + 0H40		;will reserve 0H40
				;bytes of storage as will
	.blkb	0H40		;or
	.blkw	0H20
.end literal

The .blkb and .blkw directives are the preferred methods of allocating
space.


.header level 2;Numbers

ASxxxx assumes that all numbers in the source program are to be interpreted in
decimal radix unless otherwise specified.  The .radix directive may be used
to specify the default as octal, decimal, or hexidecimal.  Individual numbers
can be designated as binary, octal, decimal, or hexidecimal through the
temporary radix prefixes shown in table 6.

Negative numbers must be preceeded by a minus sign;  ASxxxx translates
such numbers into two's complement form.  Positive numbers may (but need
not) be preceeded by a plus sign.

Numbers are always considered to be absolute values,  therefor they are
never relocatable.


.header level 2;Terms

A term is a component of an expression and may be one of the following:
.skip
.list 1
.list element
A number.
.list element
A symbol:
.list 0
.list element
A period (.) specified in an expression causes
the current location counter to be used.
.list element
A User-defined symbol.
.list element
An undefined symbol is assigned a value of zero
and inserted in the User-Defined symbol table as an
undefined symbol.
.end list 0
.list element
A single quote followed by a single ascii character, or
a double quote followed by two ascii characters.
.list element
An expression enclosed in parenthesis.  Any expression
so enclosed is evaluated and reduced to a single term
before the remainder of the expression in which it
appears is evaluated.  Parenthesis, for example, may be
used to alter the left-to-right evaluation of expressions,
(as in A*B_+C versus A*(B_+C)), or to apply a unary operator
to an entire expression (as in -(A_+B)).
.list element
A unary operator followed by a symbol or number.
.end list


.header level 2;Expressions

Expressions are combinations of terms joined together by binary
operators.  Expressions reduce to a 16-bit value. The evaluation
of an expression includes the determination of its attributes.
A resultant expression value may be one of three types (as described
later in this section): relocatable, absolute, and external.
.skip
.test page 22
Expressions are evaluate with an operand hierarchy as follows:
.skip;.literal
	*	/	%	multiplication,
				division, and
				modulus first.

	+	-		addition and
				subtraction second.

	<<	>>		left shift and
				right shift third.

	^			exclusive or fourth.

	&			logical and fifth.

	|			logical or last

	except that unary operators take precedence over binary
	operators.
.end literal
.skip

A missing or illegal operator terminates the expression analysis,
causing error codes (o) and/or (q) to be generated depending
upon the context of the expression itself.

At assembly time the value of an external (global) expression is equal to
the value of the absolute part of that expression.  For example,
the expression external+4, where 'external' is an external symbol, has
the value of 4.  This expression, however, when evaluated at link time
takes on the resolved value of the symbol 'external', plus 4.

Expressions, when evaluated by ASxxxx, are one of three types:
relocatable, absolute, or external.  The following distinctions
are important:

.list 1
.list element
An expression is relocatable if its value is fixed
relative to the base address of the program area
in which it appears; it will have an offset value
added at link time.  Terms that contain labels
defined in relocatable program areas will have
a relocatable value; similarly, a period (.) in a relocatable
program area, representing the value of the current
program location counter, will also have a relocatable value.
.list element
An expression is absolute if its value is fixed.  An
expression whose terms are numbers and ascii characters
will reduce to an absolute value.  A relocatable expression
or term minus a relocatable term, where both elements being
evaluated belong to the same program area, is an absolute
expression.  This is because every term in a program area
has the same relocation bias.  When one term is subtracted
from the other the relocation bias is zero.
.list element
An expression is external (or global) if it contains
a single global reference (plus or minus an absolute
expression value) that is not defined within the current
program.  Thus, an external expression is only partially
defined following assembly and must be resolved at link time.
.end list


.header level 1;GENERAL ASSEMBLER DIRECTIVES

An ASxxxx directive is placed in the operator field of the source
line. Only one directive is allowed per source line. Each directive
may have a blank operand field or one or more operands.  Legal
operands differ with each directive.


.header level 2;_.module Directive
Format:
.skip;.indent 8
_.module	string

The .module directive causes the string to be included in the assemblers
output file as an identifier for this particular object module.  The
string may be from 1 to 8 characters in length. Only one identifier is
allowed per assembled module. The main use of this directive is to
allow the linker to report a modules' use of undefined symbols. At link
time all undefined symbols are reported and the modules referencing them
are listed.


.header level 2;_.title Directive
Format:
.skip;.indent 8
_.title	string

The .title directive provides a character string to be placed on the second
line of each page during listing.


.header level 2;_.sbttl Directive
Format:
.skip;.indent 8
_.sbttl	string

The .sbttl directive provides a character string to be placed on the third
line of each page during listing.


.header level 2;_.page Directive
Format:
.skip;.indent 8
_.page

The .page directive causes a page ejection with a new heading to be
printed.  The new page occurs after the next line of the source program
is processed, this allows an immediately following .sbttl directive to
appear on the new page. The .page source line will not appear in the
file listing. Paging may be disabled by invoking the -p directive.

.header level 2;_.byte and _.db Directives
Format:
.skip;.literal
	.byte	exp		;Stores the binary value
	.db	exp		;of the expression in the
				;next byte.

	.byte	exp1,exp2,expn	;Stores the binary values
	.db	exp1,exp2,expn	;of the list of expressions
				;in successive bytes.

where:	exp,	represent expressions that will be
	exp1,	truncated to 8-bits of data.
	.	Each expression will be calculated
	.	as a 16-bit word expression,
	.	the high-order byte will be truncated.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .byte or .db directives are used to generate successive bytes of
binary data in the object module.


.header level 2;_.word and _.dw Directives
Format:
.skip;.literal
	.word	exp		;Stores the binary value
	.dw	exp		;of the expression in
				;the next word.

	.word	exp1,exp2,expn	;Stores the binary values
	.dw	exp1,exp2,expn	;of the list of expressions
				;in successive words.

where:	exp,	represent expressions that will occupy two
	exp1,	bytes of data. Each expression will be
	.	calculated as a 16-bit word expression.
	.	Multiple expressions must be
	expn	separated by commas.
.end literal

The .word or .dw directives are used to generate successive words of
binary data in the object module.


.header level 2;_.blkb, _.blkw, and _.ds Directives
Format:
.skip;.literal
	.blkb	N	;reserve N bytes of space
	.blkw	N	;reserve N words of space
	.ds	N	;reserve N bytes of space
.end literal

The .blkb and .ds directives reserve byte blocks in the object module;
the .blkw directive reserves word blocks.


.header level 2;_.ascii Directive
Format:
.skip;.indent 8
_.ascii	/string/
.skip
where:	string	is a string of printable ascii characters.
.skip;.left margin +16
.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .ascii
directive will give the (q) error.
.left margin -16
.skip
The .ascii directive places one binary byte of data for each character
in the string into the object module.


.header level 2;_.ascis Directive
Format:
.skip;.indent 8
_.ascis	/string/
.skip;.left margin +16
.indent -16
where:##string	is a string of printable ascii characters.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .ascis
directive will give the (q) error.
.left margin -16
.skip
The .ascis directive places one binary byte of data for each character
in the string into the object module. The last character in the string
will have the high order bit set.


.header level 2;_.asciz Directive
Format:
.skip;.indent 8
_.asciz	/string/
.skip;.left margin +16
.indent -16
where:##string	is a string of printable ascii characters.
.skip;.indent -8
/##/####represent the delimiting characters. These delimiters
may be any paired printing characters, as long as the
characters are not contained within the string itself.
If the delimiting characters do not match, the .asciz
directive will give the (q) error.
.left margin -16
.skip
The .asciz directive places one binary byte of data for each character
in the string into the object module. Following all the character
data a zero byte is inserted to terminate the character string.


.header level 2;_.radix Directive
Format:
.skip;.indent 8
_.radix	character
.skip;.left margin +16
.indent -16
where:##character represents a single character specifying the
default radix to be used for succeeding numbers.
The character may be any one of the following:
.left margin -16
.skip;.literal
		B,b	Binary

		O,o	Octal
		Q,q

		D,d	Decimal
		'blank'

		H,h	Hexidecimal
		X,x
.end literal


.header level 2;_.even Directive
Format:
.skip;.indent 8
_.even

The .even directive ensures that the current location counter contains
an even boundary value by adding 1 if the current location is odd.


.header level 2;_.odd Directive
Format:
.skip;.indent 8
_.odd

The .odd directive ensures that the current location counter contains
an odd boundary value by adding one if the current location is even.


.header level 2;_.area Directive
Format:
.skip;.indent 8
_.area	name	[(options)]
.skip;.left margin +16
.indent -16
where:##name####represents the symbolic name of the program section.
This name may be the same as any user-defined symbol
as the area names are independent of all symbols and
labels.
.skip;.indent -16
########options#specify the type of program or data area:
.break;ABS	absolute (automatically invokes OVR)
.break;REL	relocatable
.break;OVR	overlay
.break;CON	concatenate
.break;PAG	paged area
.left margin -16
.skip

The .area directive provides a means of defining and separating multiple
programming and data sections. The name is the area label used by the
assembler and the linker to collect code from various separately assembled
modules into one section. The name may be from 1 to 8 characters in length.

The options are specified within parenthesis and separated by commas
as shown in the following example:
.skip;.literal
	.area  TEST  (REL,CON)	;This section is relocatable
				;and concatenated with other
				;sections of this program area.

	.area  DATA  (REL,OVR)	;This section is relocatable
				;and overlays other sections
				;of this program area.

	.area  SYS   (ABS,OVR)	;(CON not allowed with ABS)
				;This section is defined as
				;absolute. Absolute sections
				;are always overlayed with
				;other sections of this program
				;area.

	.area  PAGE  (PAG)	;This is a paged section. The
				;section must be on a 256 byte
				;boundary and its length is
				;checked by the linker to be
				;no larger than 256 bytes.
				;This is useful for direct page
				;areas.
.end literal

The default area type is REL_|CON; i.e. a
relocatable section which is concatenated with other sections of code
with the same area name. The ABS option indicates an absolute area.
The OVR and CON options indicate if program sections of the same name
will overlay each other (start at the same location) or be concatenated
with each other (appended to each other).

Multiple invocations of the .area directive with the same name must
specify the same options or leave the options field blank, this defaults
to the previously specified options for this program area.

.tp 10
The ASxxxx assemblers automatically provide two program sections:
.skip;.left margin +24
.indent -16
'_.##_.ABS_.'######This dumby section contains all absolute
symbols and their values.
.skip;.indent -16
'__CODE'#########This is the default program/data area.
This program area is of type (REL,CON).
.left margin -24

.tp 10
The ASxxxx assemblers also automatically generate two symbols for each
program area:
.skip;.left margin +24
.indent -16
's___<area_>'######This is the starting address of the program area.
.skip;indent -16
'l___<area_>'######This is the length of the program area.
.left margin -24

.header level 2;_.org Directive
Format:
.skip;.indent 8
_.org	exp
.skip;.left margin +16
.indent -16
where:##exp#####is an absolute expression that becomes the
current location counter.
.left margin -16
.skip
The .org directive is valid only in an absolute program section and
will give a (q) error if used in a relocatable program area.  The .org
directive specifies that the current location counter is
to become the specified absolute value.


.header level 2;_.globl Directive
Format:
.skip;.indent 8
_.globl	sym1,sym2,...,symn
.skip;.literal
where:	sym1,		represent legal symbolic names. When
	sym2,...	When multiple symbols are specified,
	symn		they are separated by commas.
.end literal

A .globl directive may also have a label field and/or a comment field.

The .globl directive is provided to define (and thus provide
linkage to) symbols not otherwise defined as global symbols within
a module. In defining global symbols the directive .globl J is
similar to:
.skip
.indent 6;J _=_= expression or J::

Because object modules are linked by global symbols, these symbols are
vital to a program. All internal symbols appearing within a given program
must be defined at the end of pass 1 or they will be considered undefined.
The assembly directive (-g) can be be invoked to make all undefined
symbols global at the end of pass 1.


.header level 2;_.if, _.else, and _.endif Directives
Format:
.skip;.literal
	.if	expr
	.			;}
	.			;} range of true condition
	.			;}
	.else
	.			;}
	.			;} range of false condition
	.			;}
	.endif
.end literal

The conditional assembly directives allow you to include or exclude
blocks of source code during the assembly process, based on the
evaluation of the condition test.

The range of true condition will be processed if the expression 'expr'
is not zero (i.e. true) and the range of false condition will be
processed if the expression 'expr' is zero (i.e false). The range of
true condition is optional as is the .else directive and the range
of false condition.  The following are all valid .if/.else/.endif
constructions:
.skip;.literal
	.if	A-4		;evaluate A-4
	.byte	1,2		;insert bytes if A-4 is
	.endif			;not zero

	.if	K+3		;evaluate K+3
	.else
	.byte	3,4		;insert bytes if K+3
	.endif			;is zero

	.if	J&3		;evaluate J masked by 3
	.byte	12		;insert this byte if J&3
	.else			;is not zero
	.byte	13		;insert this byte if J&3
	.endif			;is zero
.end literal
.skip 2
The .if/.else/.endif directives may be nested upto 10 levels.

The .page directive is processed within a false condition range
to allow extended textual information to be incorporated in the
source program with out the need to use the comment delimiter (;):
.skip;.literal
	.if	0

	.page
	This text will be bypassed during assembly
	but appear in the listing file.
	.
	.
	.

	.endif
.end literal


.header level 2;_.include Directive
Format:
.skip;.indent 8
_.include	string
.skip;.left margin +16
.indent -16
where:##string##represents a delimited string that is the
file specification of an ASxxxx source file.
.left margin -16

The .include directive is used to insert a source file within the
source file currently being assembled. When this directive is encountered,
an implicit .page directive is issued. When the end of the specified
source file is reached, an implicit .page directive is issued and
input continues from the previous source file. The maximum nesting
level of source files specified by a .include directive is five.

The total number of separately specified .include files is unlimited
as each .include file is opened and then closed during each pass
made by the assembler.


.header level 2;_.\s\e\t\d\p Directive

.break
Format:
.skip;.indent 8
_.setdp [base [,area]]
.skip
The set direct page directive has a common format in all the
AS68xx assemblers.
The .setdp directive is used to inform the assembler of the current
direct page region and the offset address within the selected area.
The normal invocation methods are:
.tp 10;.skip
.literal
	.area	DIRECT	(PAG)
	.setdp

	or

	.setdp	0,DIRECT
.end literal
.skip
for all the 68xx microprocessors (the 6804 has only the paged ram area).
The commands specify that the direct page is in area DIRECT and its offset
address is 0 (the only valid value for all but the 6809 microprocessor).
Be sure to place the DIRECT area at address 0 during linking.
When the base address and area are not specified, then
zero and the current area are the defaults.  If a .setdp directive
is not issued the assembler defaults the direct page to the
area "__CODE" at offset 0.

The assembler verifies that any local variable used in a direct
variable reference is located in this area. Local variable and constant value
direct access addresses are checked to be within the address range
from 0 to 255.

External direct references are assumed by the assembler to be in
the correct area and have valid offsets.
The linker will check all direct page relocations
to verify that they are within the correct area.

The 6809 microprocessor allows the selection of the direct page
to be on any 256 byte boundary by loading the appropriate value
into the dp register. Typically one would like to select the page
boundary at link time, one method follows:
.tp 12;.skip
.literal
	.area	DIRECT	(PAG)	; define the direct page
	.setdp
	.
	.
	.
	.area	PROGRAM
	.
	ldd	#DIRECT		; load the direct page register
	tfr	a,dp		; for access to the direct page
.end literal
.skip
.tp 10
At link time specify the base and global equates to locate the
direct page:
.skip
.literal
	-b DIRECT = 0x1000
	-g DIRECT = 0x1000
.end literal
.skip
Both the area address and offset value must be specified (area and
variable names are independent). The linker will verify that the
relocated direct page accesses are within the direct page.

.tp 20
The preceeding sequence could be repeated for multiple paged areas, however
an alternate method is to define a non-paged area and use the .setdp
directive to specify the offset value:
.skip
.literal
	.area	DIRECT		; define non-paged area
	.
	.
	.
	.area	PROGRAM
	.
	.setdp	0,DIRECT	; direct page area
	ldd	#DIRECT		; load the direct page register
	tfr	a,dp		; for access to the direct page
	.
	.
	.setdp	0x100,DIRECT	; direct page area
	ldd	#DIRECT+0x100	; load the direct page register
	tfr	a,dp		; for access to the direct page
.end literal
.skip
The linker will verify that subsequent direct page references are in
the specified area and offset address range.
It is the programmers responsibility to load the dp register with the
correct page segment corresponding to the .setdp base address specified.

For those cases where a single piece of code must access a defined
data structure within a direct page and there are many pages, define
a dumby direct page linked at address 0. This dumby page is used
only to define the variable labels. Then load the dp register with
the real base address but donot use a .setdp directive.  This method
is equivalent to indexed addressing, where the dp register is the
index register and the direct addressing is the offset.


.tp 32
.header level 1;INVOKING ASXXXX

The ASxxxx assemblers are command line oriented. After the assembler
is started, enter the option(s) and file(s) to assemble following the
'argv:' prompt:
.skip
argv: [-dqxgalosf] file1 [file2 file3 ... file6]
.skip
The options are:
.skip;.literal
	d	decimal	listing
	q	octal	listing
	x	hex	listing (default)

		The listing radix affects the
		.lst, .rel, and .sym files.

	g	undefined symbols made global
	a	all user symbols made global

	l	create list   output file1.lst
	o	create object output file1.rel
	s	create symbol output file1.sym

	p	disable listing pagination

		relocatable reference flagging:

	f	by  `   in the listing file
	ff	by mode in the listing file
.end literal

The file name for the .lst, .rel, and .sym files is the first file name
specified in the command line. All output files are ascii text files
which may be edited, copied, etc.  The output files are the concatenation
of all the input files, if files are to be assembled independently
invoke the assembler for each file.

The .rel file contains a radix directive so that the linker will
use the proper conversion for this file. Linked files may have
different radices.

If the list (l) option is specified without the symbol table (s)
option, the symbol table is placed at the end of the listing file.


.header level 1;ERRORS

The ASxxxx assemblers provide limited diagnostic error codes
during the assembly process, these errors will be noted in the
listing file and printed on the stderr device.

The assembler reports the errors on the stderr device as
.skip
.lit
	?ASxxxx-Error-<*> in line nnn of filename
.end lit
.skip
where * is the error code, nnn is the line number, and filename
is the source/include file.

The errors are:
.left margin +12
.skip;.indent -6
(_.)###
This error is caused by an absolute direct assignment
of the current location counter
.indent 6
_. = expression (incorrect)
.break
rather than the correct
.indent 6
_. = _. + expression
.skip;.indent -6
(a)###
Indicates a machine specific addressing or
addressing mode error.
.skip;.indent -6
(b)###
Indicates a direct page boundary error.
.skip;.indent -6
(d)###
Indicates a direct page addressing error.
.skip;.indent -6
(i)###
Caused by an .include file error or
an .if/.endif mismatch.
.skip;.indent -6
(m)###
Multiple definitions of the same label,
multiple .module directives, or multiple
conflicting attributes in an .area directive.
.skip;.indent -6
(o)###
Directive or mnemonic error or the use
of the .org directive in a relocatable area.
.skip;.indent -6
(p)###Phase error: label location changing between
passes 2 and 3. Normally caused by having
more than one level of forward referencing.
.skip;.indent -6
(q)###
Questionable syntax: missing or improper
operators, terminators, or delimiters.
.skip;.indent -6
(r)###
Relocation error: logic operation attempted on
a relocatable term, addition of two relocatable terms,
subtraction of two relocatable terms not within the
same programming area or external symbols.
.skip;.indent -6
(u)###
Undefined symbol encountered during assembly.
.left margin -12


.header level 1;LISTING FILE

The (-l) option produces an ascii output listing file. Each page of output
contains a four line header:
.skip
.list 1
.list element;The ASxxxx program name and page number
.list element;Title from a .title directive (if any)
.list element;Subtitle from a .sbttl directive (if any)
.list element;Blank line
.end list

.skip 2;.break
Each succeeding line contains five fields:
.skip
.list 1
.list element;Error field (first three characters of line)
.list element;Current location counter
.list element;Generated code in byte format
.list element;Source text line number
.list element;Source text
.end list

The error field may contain upto 2 error flags indicating any errors
encountered while assembling this line of source code.

The current location counter field displays the 16-bit program
position. This field will be in the selected radix.

The generated code follows the program location. The listing
radix determines the number of bytes that will be displayed in this
field. Hexidecimal listing allows six bytes of data within the field,
decimal and octal allow four bytes within the field. If more than
one field of data is generated from the assembly of a single line of
source code, then the data field is repeated on successive lines.

The source text line number is printed in decimal and is followed by
the source text.

Two special cases will disable the listing of a line of source text:

.list 1
.list element;Source line with a .page directive is never listed.
.list element;Source line with a .include file directive is not listed
unless the .include file cannot be opened.
.end list

Two data field options are available to flag those bytes which will
be relocated by the linker. If the -f option is specified then
each byte to be relocated will be preceeded by the '`' character.
If the -ff option is specified  then each byte to be relocated
will be preceeded by one of the following characters:

.list 1
.list element;*###paged relocation
.list element;u###low##byte of unsigned word or unsigned byte
.list element;v###high#byte of unsigned word
.list element;p###PCR low##byte of word relocation or PCR byte
.list element;q###PCR high#byte of word relocation
.list element;r###low##byte relocation or byte relocation
.list element;s###high#byte relocation
.end list


.header level 1;SYMBOL TABLE FILE

The symbol table has two parts:

.list 1
.list element
The alphabetically sorted list of symbols and/or labels
defined or referenced in the source program.
.list element
A list of the program areas defined during assembly
of the source program.
.end list

.break;
The sorted list of symbols and/or labels contains the following information:

.list 1
.list element
Program area number (none if absolute value or external)
.list element
The symbol or label
.list element
Directly assigned symbol is denoted with an (=) sign
.list element
The value of a symbol, location of a label relative
to the program area base address (=0), or a **** indicating
the symbol or label is undefined.
.list element
The characters: G - global, R - relocatable, and X - external.
.end list

The list of program areas provides the correspondence between the
program area numbers and the defined program areas, the size of the
program areas, and the area flags (attributes).


.header level 1;OBJECT FILE

The object file is an ascii file containing the information needed
by the linker to bind multiple object modules into a complete
loadable memory image. The object module contains the following
designators:
.skip;.literal
	[XDQ][HL]
		X	Hexidecimal radix
		D	Decimal radix
		Q	Octal radix

		H	Most significant byte first
		L	Least significant byte first

	H	Header 
	M	Module
	A	Area
	S	Symbol
	T	Object code
	R	Relocation information
	P	Paging information
.end literal

Refer to the linker for a detailed description of each of the
designators and the format of the information contained in the
object file.

